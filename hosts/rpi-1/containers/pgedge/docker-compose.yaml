services:
  postgres-n1:
    image: ghcr.io/pgedge/pgedge-postgres:17-spock5-standard
    container_name: postgres-n1
    restart: always
    environment:
      # Admin for initialization/configuration
      POSTGRES_USER: ${ADMIN_USER:-admin}
      POSTGRES_PASSWORD: ${ADMIN_PASSWORD:-password}
      POSTGRES_DB: ${POSTGRES_DB:-example_db}
      # Replication user (used in DSNs)
      PGEDGE_USER: ${REPL_USER:-pgedge}
      PGEDGE_PASSWORD: ${REPL_PASSWORD:-password}
      NODE_NAME: n1
    ports:
      - target: 5432
        published: 6432
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} -h 127.0.0.1 -p 5432"]
      interval: 5s
      timeout: 3s
      retries: 20
    # configs:
    #   - source: init-extensions
    #     target: /docker-entrypoint-initdb.d/10-init-extensions.sh
    #     mode: 755
    #   - source: configure-spock
    #     target: /docker-entrypoint-initdb.d/20-configure-spock.sh
    #     mode: 755
    #   - source: restart-postgres
    #     target: /docker-entrypoint-initdb.d/30-restart-postgres.sh
    #     mode: 755
    #   - source: create-extensions
    #     target: /docker-entrypoint-initdb.d/40-create-extensions.sh
    #     mode: 755
    #   - source: relax-pg-hba
    #     target: /docker-entrypoint-initdb.d/50-relax-pg-hba.sh
    #     mode: 755
    #   - source: spock-node
    #     target: /docker-entrypoint-initdb.d/60-spock-node.sh
    #     mode: 755

  postgres-n2:
    image: pgedge/pgedge-postgres:17-spock5-standard
    container_name: postgres-n2
    restart: always
    environment:
      POSTGRES_USER: ${ADMIN_USER:-admin}
      POSTGRES_PASSWORD: ${ADMIN_PASSWORD:-password}
      POSTGRES_DB: ${POSTGRES_DB:-example_db}
      PGEDGE_USER: ${REPL_USER:-pgedge}
      PGEDGE_PASSWORD: ${REPL_PASSWORD:-password}
      NODE_NAME: n2
    ports:
      - target: 5432
        published: 6433
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB} -h 127.0.0.1 -p 5432"]
      interval: 5s
      timeout: 3s
      retries: 20
    # configs:
    #   - source: init-extensions
    #     target: /docker-entrypoint-initdb.d/10-init-extensions.sh
    #     mode: 755
    #   - source: configure-spock
    #     target: /docker-entrypoint-initdb.d/20-configure-spock.sh
    #     mode: 755
    #   - source: restart-postgres
    #     target: /docker-entrypoint-initdb.d/30-restart-postgres.sh
    #     mode: 755
    #   - source: create-extensions
    #     target: /docker-entrypoint-initdb.d/40-create-extensions.sh
    #     mode: 755
    #   - source: relax-pg-hba
    #     target: /docker-entrypoint-initdb.d/50-relax-pg-hba.sh
    #     mode: 755
    #   - source: spock-node
    #     target: /docker-entrypoint-initdb.d/60-spock-node.sh
    #     mode: 755

  # Full-mesh wiring job: executes sub_create as admin; provider DSNs use the pgedge user.
  spock-wire:
    image: ghcr.io/pgedge/pgedge-postgres:17-spock5-standard
    container_name: spock-wire
    # depends_on:
    #   postgres-n1:
    #     condition: service_healthy
    #   postgres-n2:
    #     condition: service_healthy
    environment:
      PGADMIN_USER: ${ADMIN_USER:-admin}
      PGADMIN_PASSWORD: ${ADMIN_PASSWORD:-password}
      REPL_USER: ${REPL_USER:-pgedge}
      REPL_PASSWORD: ${REPL_PASSWORD:-password}
      DBNAME: ${POSTGRES_DB:-example_db}
      # name:host:port entries (extend for more nodes)
      NODES: "n1:postgres-n1:5432,n2:postgres-n2:5432"
    command: ["/bin/bash", "/wire/run.sh"]
    restart: "no"
    # configs:
    #   - source: spock-wire-script
    #     target: /wire/run.sh
    #     mode: 755

# configs:
#   init-extensions:
#     content: |-
#       #!/usr/bin/env bash
#       set -Eeo pipefail

#       EXTENSIONS=("pg_stat_statements" "pgaudit" "snowflake" "spock" "postgis-3")

#       PGCONF="$$PGDATA/postgresql.conf"

#       echo "Setting shared_preload_libraries to: $${EXTENSIONS[*]}"

#       LIBS=$$(IFS=','; echo "$${EXTENSIONS[*]}")

#       if grep -q '^[ ]*shared_preload_libraries' "$$PGCONF"; then
#         sed -i "s|^[ ]*shared_preload_libraries.*|shared_preload_libraries = '$$LIBS'|" "$$PGCONF"
#       else
#         echo "shared_preload_libraries = '$$LIBS'" >> "$$PGCONF"
#       fi
#   configure-spock:
#     content: |-
#       #!/usr/bin/env bash
#       set -Eeo pipefail

#       PGCONF="$$PGDATA/postgresql.conf"

#       echo "Initializing required spock configuration parameters in postgresql.conf"

#       # Allow connections from any address (for demo purposes)
#       echo "listen_addresses = '*'"              >> "$$PGCONF"

#       # Enable logical replication
#       echo "wal_level = 'logical'"                     >> "$$PGCONF"
#       echo "max_worker_processes = 10"                 >> "$$PGCONF"
#       echo "max_replication_slots = 10"                >> "$$PGCONF"
#       echo "max_wal_senders = 10"                      >> "$$PGCONF"
#       echo "track_commit_timestamp = 'on'"             >> "$$PGCONF"

#       # Set Spock parameters
#       echo "spock.enable_ddl_replication = 'on'"            >> "$$PGCONF"
#       echo "spock.include_ddl_repset = 'on'"                >> "$$PGCONF"
#       echo "spock.allow_ddl_from_functions = 'on'"          >> "$$PGCONF"
#       echo "spock.conflict_resolution = 'last_update_wins'" >> "$$PGCONF"
#       echo "spock.save_resolutions = 'on'"                  >> "$$PGCONF"
#       echo "spock.conflict_log_level = 'DEBUG'"             >> "$$PGCONF"
#   restart-postgres:
#     content: |-
#       #!/usr/bin/env bash
#       set -Eeo pipefail

#       echo "Restarting PostgreSQL to apply configuration changes..."
#       pg_ctl -D "$$PGDATA" -m fast restart
#   create-extensions:
#     content: |-
#       #!/usr/bin/env bash
#       set -Eeo pipefail

#       EXTENSIONS=("pg_stat_statements" "pgaudit" "snowflake" "spock" "vector" "postgis")

#       echo "Initializing extensions: $${EXTENSIONS[*]}"
#       for EXT in "$${EXTENSIONS[@]}"; do
#         echo "Creating extension: $$EXT"
#         psql -v ON_ERROR_STOP=1 --username "$$POSTGRES_USER" --dbname "$$POSTGRES_DB" -c "CREATE EXTENSION IF NOT EXISTS \"$$EXT\";"
#       done
#   relax-pg-hba:
#     content: |-
#       #!/usr/bin/env bash
#       set -Eeo pipefail
#       echo "host all all 0.0.0.0/0 md5" >> "$$PGDATA/pg_hba.conf"
#       echo "host all all ::/0 md5"     >> "$$PGDATA/pg_hba.conf"
#       pg_ctl -D "$$PGDATA" -m fast reload
#   # Per-node setup: also ensures the pgedge role exists; node_create uses pgedge in DSN.
#   spock-node:
#     content: |-
#       #!/usr/bin/env bash
#       set -Eeo pipefail

#       : "$${NODE_NAME:?NODE_NAME not set}"
#       DB="$${POSTGRES_DB:-example_db}"

#       # Admin executor (local)
#       ADMIN="$${POSTGRES_USER:-admin}"
#       ADMIN_PASS="$${POSTGRES_PASSWORD}"

#       # Replication user (used in DSNs)
#       REPL_USER="$${PGEDGE_USER:-pgedge}"
#       REPL_PASS="$${PGEDGE_PASSWORD:-password}"

#       HOST="postgres-$${NODE_NAME}"
#       PORT="$${PGPORT:-5432}"

#       export PGPASSWORD="$${ADMIN_PASS}"

#       echo "[spock-node] Ensuring replication role '$$REPL_USER' exists and is configured..."
#       EXISTS=$$(psql -tA -U "$$ADMIN" -d "$$DB" -c "SELECT 1 FROM pg_roles WHERE rolname = '$$REPL_USER' LIMIT 1;" || true)
#       if [ "$$EXISTS" != "1" ]; then
#         psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" \
#           -c "CREATE ROLE \"$$REPL_USER\" LOGIN REPLICATION PASSWORD '$$REPL_PASS';"
#       else
#         psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" \
#           -c "ALTER ROLE \"$$REPL_USER\" LOGIN REPLICATION PASSWORD '$$REPL_PASS';"
#       fi

#       # Practical privileges (safe to re-run)
#       psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" -c "GRANT pg_read_all_data  TO \"$$REPL_USER\";"
#       psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" -c "GRANT pg_write_all_data TO \"$$REPL_USER\";"
#       psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" -c "GRANT CREATE, TEMP ON DATABASE \"$$DB\" TO \"$$REPL_USER\";"
#       psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES   TO \"$$REPL_USER\";"
#       psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO \"$$REPL_USER\";"
#       psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" -c "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO \"$$REPL_USER\";"

#       echo "[spock-node] Ensuring spock node '$${NODE_NAME}' exists (dsn uses '$${REPL_USER}')..."
#       NODE_EXISTS=$$(psql -tA -U "$$ADMIN" -d "$$DB" -c "SELECT 1 FROM spock.node WHERE node_name='$${NODE_NAME}' LIMIT 1;" || true)
#       if [ "$$NODE_EXISTS" != "1" ]; then
#         psql -v ON_ERROR_STOP=1 -U "$$ADMIN" -d "$$DB" \
#           -c "SELECT spock.node_create(node_name := '$${NODE_NAME}', dsn := 'host=$${HOST} port=$${PORT} dbname=$${DB} user=$${REPL_USER} password=$${REPL_PASS}');"
#         echo "[spock-node] node '$${NODE_NAME}' created."
#       else
#         echo "[spock-node] node '$${NODE_NAME}' already present; skipping."
#       fi
#   # Wiring script: admin executes sub_create; provider_dsn uses replication user.
#   spock-wire-script:
#     content: |-
#       #!/usr/bin/env bash
#       set -Eeo pipefail

#       : "$${NODES:?NODES list is required, e.g. NODES='n1:postgres-n1:5432,n2:postgres-n2:5432'}"
#       : "$${PGADMIN_USER:?PGADMIN_USER required}"
#       : "$${PGADMIN_PASSWORD:?PGADMIN_PASSWORD required}"
#       : "$${REPL_USER:?REPL_USER required}"
#       : "$${REPL_PASSWORD:?REPL_PASSWORD required}"
#       : "$${DBNAME:?DBNAME required}"

#       IFS=',' read -r -a NODE_ENTRIES <<< "$$NODES"
#       NAMES=(); HOSTS=(); PORTS=()
#       for entry in "$${NODE_ENTRIES[@]}"; do
#         name="$${entry%%:*}"
#         rest="$${entry#*:}"
#         host="$${rest%%:*}"
#         port="$${rest##*:}"
#         NAMES+=("$$name"); HOSTS+=("$$host"); PORTS+=("$$port")
#       done

#       psql_ok () {
#         local host="$$1" port="$$2" user="$$3" pass="$$4" sql="$$5"
#         PGPASSWORD="$$pass" psql -h "$$host" -p "$$port" -U "$$user" -d "$$DBNAME" -t -A -v ON_ERROR_STOP=1 -c "$$sql" >/dev/null 2>&1
#       }

#       echo "[wire] Waiting for all nodes (admin access)..."
#       for i in "$${!NAMES[@]}"; do
#         h="$${HOSTS[$$i]}"; p="$${PORTS[$$i]}"
#         until psql_ok "$$h" "$$p" "$$PGADMIN_USER" "$$PGADMIN_PASSWORD" "select 1"; do
#           echo "[wire] waiting for $$h:$$p ..."
#           sleep 1
#         done
#       done

#       echo "[wire] Waiting until each DB reports its own spock.node row..."
#       for i in "$${!NAMES[@]}"; do
#         n="$${NAMES[$$i]}"; h="$${HOSTS[$$i]}"; p="$${PORTS[$$i]}"
#         until PGPASSWORD="$$PGADMIN_PASSWORD" psql -h "$$h" -p "$$p" -U "$$PGADMIN_USER" -d "$$DBNAME" -t -A \
#           -c "SELECT 1 FROM spock.node WHERE node_name='$$n' LIMIT 1;" | grep -q '^1$$'; do
#           echo "[wire] waiting for spock.node '$$n' on $$h:$$p ..."
#           sleep 1
#         done
#       done

#       echo "[wire] Creating full-mesh subscriptions (idempotent; providers use '$$REPL_USER')..."
#       for i in "$${!NAMES[@]}"; do
#         ai="$${NAMES[$$i]}"; ah="$${HOSTS[$$i]}"; ap="$${PORTS[$$i]}"
#         for j in "$${!NAMES[@]}"; do
#           [ "$$i" -eq "$$j" ] && continue
#           bj="$${NAMES[$$j]}"; bh="$${HOSTS[$$j]}"; bp="$${PORTS[$$j]}"
#           sub="sub_$${ai}_$${bj}"
#           echo "[wire] ensuring $$sub exists on $$ai -> $$bj ..."
#           PGPASSWORD="$$PGADMIN_PASSWORD" psql -h "$$ah" -p "$$ap" -U "$$PGADMIN_USER" -d "$$DBNAME" -v ON_ERROR_STOP=1 \
#             -c "SELECT spock.sub_create(subscription_name := '$$sub', provider_dsn := 'host=$$bh port=$$bp dbname=$$DBNAME user=$$REPL_USER password=$$REPL_PASSWORD') WHERE NOT EXISTS (SELECT 1 FROM spock.subscription WHERE sub_name='$$sub');" \
#             >/dev/null
#         done
#       done
#       echo "[wire] Wiring complete."
